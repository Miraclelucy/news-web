20171120 动态代理
	///////////////////////////////////
类加载器:(了解)
	类加载:
		我们编写的.java文件,jvm会将变成.class文件.该文件要想运行,必须加载内存中,然后会生成一个对象.Class对象
	类加载器层次结构
		引导类加载器	rt.jar
		扩展类加载器	ext/*.jar
		应用类加载器	我们自己编写类
	全盘负责委托机制:
		当一个类运行的时候,有可能有其他类,应用类加载器询问扩展类加载器:你加载过这些类吗?
		扩展类加载器在向上问(引导类加载器):你加载过这些类吗?
		引导类加载器:我查查,有一个是我负责,我加载.
		扩展类加载器:接下来我来查,有几个是我负责,我加载,还有几个类我已经加载完成了,你可以直接使用
		应用类加载器:收到了 剩下的我来
////////////////////////
案例3-统一编码
技术分析:
	动态代理
/////////////////////
静态代理书写步骤:
	1.要求被装饰者和装饰者实现同一个接口或者继承同一个类
	2.在装饰者中要有被装饰者的引用
	3.对需要加强的方法进行加强
	4.对不需要加强的方法调用原来的方法
////////////////////////////
动态代理:
	在项目运行的时候才创建一个代理对象,对方法进行增强(控制)
	方式1:
		jdk中Proxy类,前提:实现接口
	方式2:
		spring中cglib,前提:继承类

	动态的在内存中创建一个代理对象
		Object Proxy.newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)
			参数说明:
				ClassLoader:代理对象类加载器 一般我们使用的是被代理对象的类加载器
				Class[]:代理对象需要实现接口 一般我们使用的是被搭理对象所实现的所有接口
				InvocationHandler:执行处理类.在这里面对方法进行加强

			invocationHandler中只有一个方法
				Object invoke(Object proxy, Method method, Object[] args)
					参数说明:
						proxy:代理对象
						method:当前执行的方法
						args:当前方法执行的时候所需要的参数
						返回值:就是当前method对象执行的返回值
 //////////////////////////////////////////////////